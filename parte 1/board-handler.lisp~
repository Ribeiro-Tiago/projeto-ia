;;;; board-handler.lisp
;;;; Funções de interação com o tabuleiro
;;;; Disciplina de IA - 2018 / 2019
;;;; Autor: Tiago Alves & Tiago Ribeiro

(defun valid-cell (index) 
  "Função auxiliar que valida se o index da célula está válido (entre 0 e 5).
   Retorna T se sim, nil caso contrário"
  (AND (>= index 0) (<= index 5))
)

(defun valid-row (index) 
  "Função auxiliar que valida se o index da linha está válido (0 ou 1) 
   Retorna T se sim, nil caso contrário"
  (OR (= index 0) (= index 1))
)

(defun get-row (index board)
  "Valida o {index} e devolvee a linha do {board} correspondente ao {index} ou nil se o {index} for inválido"
  (cond 
        ((not (valid-row index)) nil)
        ((= index 0) (first board))
        (t (second board)))
)

(defun get-cell (rowIndex cellIndex board)
  "Valida o {rowIndex} e {cellIndex} e devolvee a célula do {board} correspondente 
   ao [rowIndex][cellIndex] ou nil se algum dos indexes for inválido"
  (cond 
     ((not (and (valid-cell cellIndex) (valid-row rowIndex))) nil)
     (t (nth cellIndex (get-row rowIndex board))))
)


(defun board-emptyp (board) 
  "Verifica se todos os átomos da lista são 0. Retorna T se sim, nil caso contrário"
  (eval 
   (cons 'and 
         (mapcar 
             #'(lambda (tabuleiro &aux (row
                                          (eval 
                                           (cons 'and 
                                                 (mapcar #'(lambda (linha &aux (emptyCell (= linha 0))) emptyCell) tabuleiro)
                                           )
                                          )
                                       )
                       ) 
                       row
               )
             board
         )
    ))
)

(defun replace-position (cellIndex row &optional (value 0))
  "Valida se {row} e {cellIndex} são válidos. 
   Se sim, substitui o valor na [row][cellIndex] com {value} e retorna uma nova linha
   Caso contrário devolve nil"
  (cond
    ((null row) ())
    ((not (valid-cell cellIndex)) nil)
    ((= cellIndex 0) (cons value (rest row)))
    (t (cons(first row) (replace-position (- cellIndex 1) (rest row) value))))
)

(defun update-board (rowIndex cellIndex board &optional (value 0))
  "Valida se {rowIndex}, {cellIndex} e {board} são válidos.
  Se sim, atualiza a posição [rowIndex][cellIndex] do {board} com o {value} recebido e retorna o novo tabuleiro
  Caso cotnrário retorna nil"
  (cond 
     ((null board) nil)
     ((not (and (valid-cell cellIndex) (valid-row rowIndex))) nil)
     ((= rowIndex 0) 
        (cons 
           (replace-position cellIndex (get-row rowIndex board) value) 
           (list (second board))
        ))

     (t (cons 
           (first board) 
           (list (replace-position cellIndex (get-row rowIndex board) value))
        )))
)

(defun add-position (rowIndex cellIndex board) 
  "Valida se {rowIndex}, {cellIndex} e {board} são válidos.
  Se sim, incrementa o valor na posição [rowIndex[cellIndex]] do {board} por 1
  Caso contrário, retorna nil"
  (cond
     ((null board) ())
     ((not (and (valid-cell cellIndex) (valid-row rowIndex))) nil)    
     (t (+ 1 (get-cell rowIndex cellIndex board)))
  )
)


(defun get-next-cell (rowIndex cellIndex isFirstCall)
  "Calcula e retorna o index da próxima coluna com base no index da coluna e linha atual"
  (cond 
    ((AND (> cellIndex 0) (= rowIndex 0) (NOT isFirstCall)) (- cellIndex 1))
    ((AND (< cellIndex 5) (= rowIndex 1) (NOT isFirstCall)) (1+ cellIndex))
    (t cellIndex)
  )
)

(defun get-next-row (rowIndex cellIndex isFirstCall)
  "Calcula e retorna o index da próxima linha com base no index da coluna e linha atual"
  (cond 
    ((AND (= cellIndex 0) (= rowIndex 0) (NOT isFirstCall)) (1+ rowIndex))
    ((AND (= cellIndex 5) (= rowIndex 1) (NOT isFirstCall)) (- rowIndex 1))
    (t rowIndex)
  )
)

(defun allocate-pieces (numPieces rowIndex cellIndex &optional (board (start-board)) (isFirstCall nil))
  "Valida {rowIndex}, {cellIndex} e {board}. Se não forem válidos, retorna nil
   Se forem, chama percorre o {board} recursivamente com base no {numPieces} e 
   em cada posição incrementa um valor. Na posição inicial, deixa um valor de 0.
   No final, se a posição for 1 3 ou 5, \"captura\" essas peças e retorna o {board}, 
   senão retorna o {board} com os novos valores"
  (let* (
          (nextCell (get-next-cell rowIndex cellIndex isFirstCall)) 
          (nextRow (get-next-row rowIndex cellIndex isFirstCall))
          (value (cond (isFirstCall 0)
                       (t (add-position nextRow nextCell board))))
        )

    (cond
      ((null board) nil)
      ((not (and (valid-cell cellIndex) (valid-row rowIndex))) nil)
      ((>= numPieces 0)
         (allocate-pieces 
             (- numPieces 1)
             nextRow
             nextCell
             (update-board 
                 nextRow 
                 nextCell
                 board
                 value
             )
         )
      ) 
      ((or (= cellIndex 1) (= cellIndex 3) (= cellIndex 5)) (update-board rowIndex cellIndex board))
      (t board))
   )
  ) 
)